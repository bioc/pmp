---
title: "Peak Matrix Processing for metabolomics data sets"
author: 
    name: "Andris Jankevics"
    affiliation: Phenome Centre Birmingham, University of Birmingham
    email: a.jankevics@bham.ac.uk

package: pmp

date: "`r Sys.Date()`"
output: 
    BiocStyle::html_document:
        toc: true
        toc_depth: 2  
        number_sections: true  
        toc_float: true

bibliography: pmp.bib

vignette: >
    %\VignetteIndexEntry{Peak Matrix Processing for metabolomics data sets}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

# Installation

```{r eval=FALSE, include=TRUE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("pmp")
```

```{r message=FALSE, warning=FALSE}
library(pmp)
library(SummarizedExperiment)
library(S4Vectors)
library(pcaMethods)
library(ggplot2)
```

# Introduction

Metabolomics data processing workflows consist of multiple steps including peak 
picking or raw data processing, quality assurance, missing value
imputation, normalisation and scaling. Several tools (commercial,
R and non-R based) are commonly used for raw data processing 
which generate outputs in the form of a two dimensional data matrix and meta 
data.  

These outputs contain hundreds or thousands of so called uninformative or 
unreproducible features. Such features could strongly hinder outputs of 
subsequent statistical analysis, biomarker discovery or metabolic 
pathway inference. Common practice is to apply peak matrix validation and 
filtering procedures as described in @guida2016, @broadhurst2018 and 
@schiffman2019. 

Functions within `pmp` package are designed to help users to prepare data for 
further statistical data analysis in fast, easy to use and reproducible manner.

This document showcases the commonly used peak matrix processing steps of 
metabolomics data sets.

# Data formats

Recent review for R packages in metabolomics
[@stanstrup2019] covers a broad range of heterogenous tools is availiable as 
part of `Bioconductor` sofware collection or on `CRAN`, `Github` and similar 
public repositories. `pmp` package utilises `r Biocpkg("SummarizedExperiment")`
class from Bioconductor for data input and output.

For example, outputs from widely used `r Biocpkg("xcms")` package can be 
relatively easy converted to `SummarizedExperiment` object using functions 
`featureDefinitions`, `featureValues` and `pData` on `xcms` output object. 

Additioanlly `pmp` supports to input data to be any matrix-like `R` data 
structure (e.g. and ordinary matrix, a data frame). If input if a matrix-like
structure tools from `pmp` package will perform several checks for data 
integrity as well. Please see section \@ref(endomorphisms) for more details.

# Example data set, MTBLS79

In this tutorial we will be using  an direct infusion mass spectrometry (DIMS) 
data set consisting of 172 samples measured across 8 batches and is included in
`pmp` package as `SummarizedExperiemnt` class object `MTBLS79`. 
More detailed description of the data set is available from  @kirwan2014, 
[MTBLS79](https://www.ebi.ac.uk/metabolights/MTBLS79) and R man page.

```{r, eval=FALSE}
help ("MTBLS79")
```

For the purpose of this tutorial we will subset samples measured in batches 
from 1 to 6.

```{r}
MTBLS79 <- MTBLS79[, MTBLS79$Batch %in% c(7:8)]
MTBLS79
```

This data set before peak matrix filtering contains 128 samples, 2488 features
and 11627 missing values across all samples what is roughly around 3.6%.

```{r}
sum(is.na(assay(MTBLS79)))
sum(is.na(assay(MTBLS79))) / length(assay(MTBLS79)) * 100
```

```{r}
pc <- pca(t(assay(MTBLS79)), method="nipals", scale="none", center=TRUE)

pc
```

```{r}
pcdf <- as.data.frame(scores(pc))
pcdf$Class <- MTBLS79$Class
ggplot(pcdf, aes(PC1, PC2, colour=Class)) +
    geom_point(size=2) + stat_ellipse() + theme_bw() + 
    scale_color_brewer(palette="Set1")
```

# Filtering a data set

Filter MV by sample
```{r}
MTBLS79_filtered <- filter_samples_by_mv(df=MTBLS79, max_perc_mv=0.1)

MTBLS79_filtered

sum(is.na(assay(MTBLS79_filtered)))
```

Filter MV fraction of quality control (QC) samples.
```{r}
MTBLS79_filtered <- filter_peaks_by_fraction(df=MTBLS79_filtered, min_frac=0.9, 
    classes=MTBLS79_filtered$Class, method="QC", qc_label="QC")

MTBLS79_filtered

sum(is.na(assay(MTBLS79_filtered)))
```

Filter by MV fraction across all samples.
```{r}
MTBLS79_filtered <- filter_peaks_by_fraction(df=MTBLS79_filtered, min_frac=0.9, 
    classes=MTBLS79_filtered$Class, method="across", qc_label="QC")

MTBLS79_filtered

sum(is.na(assay(MTBLS79_filtered)))
```

Filter by RSD%
```{r}
MTBLS79_filtered <- filter_peaks_by_rsd(df=MTBLS79_filtered, max_rsd=30, 
    classes=MTBLS79_filtered$Class, qc_label="QC")

MTBLS79_filtered

sum(is.na(assay(MTBLS79_filtered)))
```

```{r}
pc <- pca(t(assay(MTBLS79_filtered)), method="nipals", scale="none", 
    center=TRUE)

pc
```

```{r}
pcdf <- as.data.frame(scores(pc))
pcdf$Class <- MTBLS79_filtered$Class
ggplot(pcdf, aes(PC1, PC2, colour=Class)) +
    geom_point(size=2) + stat_ellipse() + theme_bw() + 
    scale_color_brewer(palette="Set1")
```

# Data normalisation

Probabilistic quotient normalisation (PQN) and normalisation the the total
signal intensity methods are implemented for normalisation of biological
variability across measured samples.

```{r}
MTBLS79_pqn_normalised <- pqn_normalisation(df=MTBLS79_filtered, 
    classes=MTBLS79_filtered$Class, qc_label="QC")
```

# Missing value imputation

several
commonly used missing value imputation algorithms. Supported methods are 
k-nearest neighbours (knn), random forests (rf), Bayesian PCA missing value 
estimator (bpca), mean or median value of the given feature and constant 
small value.

```{r}
MTBLS79_mv_imputed <- mv_imputation(df=MTBLS79_pqn_normalised, method="knn")
```

# Data scaling

Variance stabilising generalised logarithm transformation (glog) algorithm is 
implimented to help to minimise contributions from unwanted technical 
variaton of sample collection.

```{r}
MTBLS79_glog <- glog_transformation(df=MTBLS79_mv_imputed,
    classes=MTBLS79_filtered$Class, qc_label="QC")
```

```{r plot_glog}
glog_plot_optimised_lambda(df=MTBLS79_mv_imputed, optimised_lambda=718580657,
    classes=MTBLS79_filtered$Class, qc_label="QC")
```

```{r}
pc <- pca(t(assay(MTBLS79_glog)), method="nipals", scale="none")

pc
```

```{r}
pcdf <- as.data.frame(scores(pc))
pcdf$Class <- MTBLS79_filtered$Class
ggplot(pcdf, aes(PC1, PC2, colour=Class)) +
    geom_point(size=2) + stat_ellipse() + theme_bw() + 
    scale_color_brewer(palette="Set1")
```

# Processing history

```{r}
metadata(MTBLS79_filtered)$processing_history
```


# Data integrity check and endomorphisms {#endomorphisms}

`pmp` is designed to validate input data if user choose not to use 
`r Biocpkg("SummarizedExperiment")` class objet. For example, if input is 
`matrix` with features stored in columns and sample in rows, any function of
`pmp` package will be able to handle this object.

```{r}
peak_matrix <- t(assay(MTBLS79))
sample_classes <- MTBLS79$Class

class(peak_matrix)
dim(peak_matrix)
class(sample_classes)
```

Let's try to use these objects as input for `mv_imputation`.

```{r message=TRUE, warning=TRUE}
mv_imputed <- mv_imputation(df=peak_matrix, method="mn")

class (mv_imputed)
dim (mv_imputed)
```

Note that `pmp` has automatically transposed input object to use largest
dimension as features, while original R data type `matrix` has been retained
also for function output.

# Session information

```{r}
sessionInfo()
```

# References

